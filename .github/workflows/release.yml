name: build weekly snapshot

on:
  push:
    tags:
      - '*'
  schedule:
    - cron: '0 04 * * 1'

permissions:
  contents: write

jobs:
  prepare_release:
    name: prepare release
    runs-on: ubuntu-latest
    outputs:
      snapshot_tag: ${{ steps.snapshot.outputs.snapshot_tag }}
    steps:
      - name: Checkout repo (for tagging)
        uses: actions/checkout@v3

      - name: Determine snapshot tag (YYwWW) or use manual tag
        id: snapshot
        run: |
          set -euo pipefail
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            SNAPSHOT_TAG="${GITHUB_REF#refs/tags/}"
            echo "Manual tag detected: $SNAPSHOT_TAG"
          else
            YEAR=$(date +%y)
            WEEK=$(date +%V)
            SNAPSHOT_TAG="${YEAR}w${WEEK}"
            echo "Generated weekly snapshot tag: $SNAPSHOT_TAG"
          fi
          echo "snapshot_tag=$SNAPSHOT_TAG" >> "$GITHUB_OUTPUT"

      - name: Ensure tag exists (create/push if this run wasn't a tag push)
        if: ${{ startsWith(github.ref, 'refs/tags/') == false }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.snapshot.outputs.snapshot_tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
          if git ls-remote --tags origin "refs/tags/${TAG}" | grep -q "refs/tags/${TAG}"; then
            echo "Tag ${TAG} already exists on remote; skipping pushing"
          else
            git tag -a "${TAG}" -m "Snapshot ${TAG} (generated by workflow)"
            git push origin "refs/tags/${TAG}"
            echo "Pushed tag ${TAG}"
          fi

      - name: Ensure GitHub release exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ steps.snapshot.outputs.snapshot_tag }}"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists"
          else
            gh release create "$TAG" --generate-notes --title "Snapshot $TAG"
            echo "Created release $TAG"
          fi

  build:
    name: build (matrix)
    runs-on: ubuntu-latest
    needs: prepare_release
    strategy:
      matrix:
        target:
          - name: box64
            arch: arm64
          - name: loader
            arch: arm64
            lts_major: 6
            libc: musl
          - name: loader
            arch: arm64
            lts_major: 6
            libc: glibc
          - name: loader
            arch: arm64
            lts_major: 6
            libc: android-ndk
          - name: loader
            arch: arm64
            lts_major: 5
            libc: musl
          - name: loader
            arch: arm64
            lts_major: 5
            libc: glibc
          - name: loader
            arch: arm64
            lts_major: 5
            libc: android-ndk

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Install build deps
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential wget curl jq cmake git bc bison flex unzip musl-tools \
            libssl-dev libncurses5-dev xz-utils libelf-dev \
            gcc-aarch64-linux-gnu g++-aarch64-linux-gnu binutils-aarch64-linux-gnu \
            pkg-config

      - name: Build artifact
        env:
          MATRIX_TARGET_NAME: ${{ matrix.target.name }}
          MATRIX_TARGET_ARCH: ${{ matrix.target.arch }}
          MATRIX_TARGET_LTS: ${{ matrix.target.lts_major }}
          MATRIX_TARGET_LIBC: ${{ matrix.target.libc }}
          WORKDIR: ${{ github.workspace }}
        run: |
          set -euo pipefail
          mkdir -p "$WORKDIR/out"

          # map arch to host triple when needed
          HOST_TRIPLE=""
          if [ "${MATRIX_TARGET_ARCH}" = "arm64" ]; then
            HOST_TRIPLE="aarch64-linux-gnu"
          fi

          if [ "$MATRIX_TARGET_NAME" = "box64" ]; then
            # shallow clone latest
            git clone --depth 1 https://github.com/ptitSeb/box64.git
            cd box64 || exit 1

            # attempt to get a tag; fallback to commit hash if none
            BOX64_VERSION=$(git describe --tags --abbrev=0 2>/dev/null || git rev-parse --short HEAD || echo "unknown")
            echo "Detected BOX64: $BOX64_VERSION"
            echo "$BOX64_VERSION" > "$WORKDIR/out/v_box64.txt"

            mkdir -p build && cd build

            # If targeting arm64 on x86 runner, ask cmake to use the cross-compiler
            if [ -n "$HOST_TRIPLE" ]; then
              cmake .. -DCMAKE_BUILD_TYPE=Release \
                       -DCMAKE_C_COMPILER="${HOST_TRIPLE}-gcc" \
                       -DCMAKE_CXX_COMPILER="${HOST_TRIPLE}-g++" \
                       -DCMAKE_SYSTEM_NAME=Linux \
                       -DCMAKE_SYSTEM_PROCESSOR=aarch64
            else
              cmake .. -DCMAKE_BUILD_TYPE=Release
            fi

            make -j"$(nproc)"
            # copy binary to out (if built)
            cp box64 "$WORKDIR/out/" || true

          elif [ "$MATRIX_TARGET_NAME" = "loader" ]; then
            LTS=${MATRIX_TARGET_LTS:?No LTS specified}
            LIBC=${MATRIX_TARGET_LIBC:?No libc specified}
            LIBC_SUFFIX=""
            if [ -n "${MATRIX_TARGET_LIBC:-}" ]; then
              LIBC_SUFFIX="-${MATRIX_TARGET_LIBC}"
            fi
            if [ "${MATRIX_TARGET_ARCH}" != "arm64" ]; then
              echo "Unsupported loader arch: ${MATRIX_TARGET_ARCH}. This matrix is arm64-only."
              exit 1
            fi
            # pick newest active longterm release for this major (e.g. 6.12.x / 5.15.x)
            KERNEL_SOURCE=$(
              curl -fsSL "https://www.kernel.org/releases.json" \
                | jq -r --arg lts "$LTS" '
                    [
                      .releases[]
                      | select(.moniker == "longterm")
                      | select(.iseol == false)
                      | select(.version | startswith($lts + "."))
                      | {version, source}
                    ]
                    | sort_by(.version | split(".") | map(tonumber))
                    | last
                    | .source // empty
                  '
            )

            if [ -z "$KERNEL_SOURCE" ]; then
              echo "Failed to detect active longterm kernel for major $LTS"
              exit 1
            fi
            KERNEL_FULL=$(basename "$KERNEL_SOURCE")
            KERNEL_VERSION=${KERNEL_FULL#linux-}
            KERNEL_VERSION=${KERNEL_VERSION%.tar.xz}
            echo "Detected kernel LTS $LTS (${MATRIX_TARGET_ARCH}/${LIBC}): $KERNEL_VERSION"
            echo "$KERNEL_VERSION" > "$WORKDIR/out/v_kernel_lts${LTS}-${MATRIX_TARGET_ARCH}${LIBC_SUFFIX}.txt"

            wget -q "$KERNEL_SOURCE"
            tar xf "$KERNEL_FULL"
            cd "linux-$KERNEL_VERSION" || exit 1

            # Build arm64 kernel image for the selected LTS series.
            export KCFLAGS="-Wno-error=array-bounds"
            make ARCH=arm64 CROSS_COMPILE="${HOST_TRIPLE}-" defconfig
            make -j"$(nproc)" ARCH=arm64 KCFLAGS="$KCFLAGS" CROSS_COMPILE="${HOST_TRIPLE}-" Image
            KERNEL_OUT="Image-arm64-kernel${KERNEL_VERSION}-lts${LTS}${LIBC_SUFFIX}"
            cp arch/arm64/boot/Image "$WORKDIR/out/$KERNEL_OUT"

            # Build a real arm64 loader binary with libc-specific toolchains.
            {
              echo '#include <errno.h>'
              echo '#include <stdio.h>'
              echo '#include <stdlib.h>'
              echo '#include <string.h>'
              echo '#include <unistd.h>'
              echo
              echo 'int main(int argc, char **argv) {'
              echo '  const char *kernel = getenv("ONYX_KERNEL");'
              echo '  const char *cmdline = getenv("ONYX_CMDLINE");'
              echo "  if (!cmdline || cmdline[0] == '\\0') cmdline = \"console=ttyAMA0\";"
              echo '  if (!kernel || kernel[0] == '"'"'\0'"'"') {'
              echo '    if (argc < 2) {'
              echo '      fprintf(stderr, "usage: %s <kernel-image>\n", argv[0]);'
              echo '      return 2;'
              echo '    }'
              echo '    kernel = argv[1];'
              echo '  }'
              echo
              echo '  char *const load_argv[] = {'
              echo '      "kexec", "-l", (char *)kernel, "--append", (char *)cmdline, NULL};'
              echo '  execvp("kexec", load_argv);'
              echo '  fprintf(stderr, "failed to exec kexec -l: %s\n", strerror(errno));'
              echo '  return 1;'
              echo '}'
            } > /tmp/onyx_loader.c

            LOADER_OUT="loader-arm64-kernel${KERNEL_VERSION}-lts${LTS}${LIBC_SUFFIX}"
            case "$LIBC" in
              glibc)
                if ! command -v zig >/dev/null 2>&1; then
                  ZIG_VERSION="0.13.0"
                  ZIG_TARBALL="zig-linux-x86_64-${ZIG_VERSION}.tar.xz"
                  wget -q "https://ziglang.org/download/${ZIG_VERSION}/${ZIG_TARBALL}" -O "/tmp/${ZIG_TARBALL}"
                  tar -xf "/tmp/${ZIG_TARBALL}" -C /tmp
                  export PATH="/tmp/zig-linux-x86_64-${ZIG_VERSION}:$PATH"
                fi
                zig cc -target aarch64-linux-gnu.2.17 -O2 -s /tmp/onyx_loader.c -o "$WORKDIR/out/$LOADER_OUT"
                ;;
              musl)
                if ! command -v zig >/dev/null 2>&1; then
                  ZIG_VERSION="0.13.0"
                  ZIG_TARBALL="zig-linux-x86_64-${ZIG_VERSION}.tar.xz"
                  wget -q "https://ziglang.org/download/${ZIG_VERSION}/${ZIG_TARBALL}" -O "/tmp/${ZIG_TARBALL}"
                  tar -xf "/tmp/${ZIG_TARBALL}" -C /tmp
                  export PATH="/tmp/zig-linux-x86_64-${ZIG_VERSION}:$PATH"
                fi
                zig cc -target aarch64-linux-musl -O2 -s -static /tmp/onyx_loader.c -o "$WORKDIR/out/$LOADER_OUT"
                ;;
              android-ndk)
                NDK_VERSION="r27c"
                NDK_ZIP="android-ndk-${NDK_VERSION}-linux.zip"
                NDK_ROOT="/tmp/android-ndk-${NDK_VERSION}"
                if [ ! -x "${NDK_ROOT}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang" ]; then
                  wget -q "https://dl.google.com/android/repository/${NDK_ZIP}" -O "/tmp/${NDK_ZIP}"
                  unzip -q "/tmp/${NDK_ZIP}" -d /tmp
                fi
                "${NDK_ROOT}/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang" \
                  -O2 -s /tmp/onyx_loader.c -o "$WORKDIR/out/$LOADER_OUT"
                ;;
              *)
                echo "Unsupported loader libc: $LIBC. Supported: glibc, musl, android-ndk"
                exit 1
                ;;
            esac

            # Wrapper to trigger kexec load + execute.
            WRAP_OUT="loader-run-arm64-lts${LTS}${LIBC_SUFFIX}.sh"
            {
              echo '#!/usr/bin/env bash'
              echo 'set -euo pipefail'
              echo 'HERE=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)'
              echo "BIN=\"\${1:-\$HERE/$LOADER_OUT}\""
              echo "KERNEL=\"\${2:-\$HERE/$KERNEL_OUT}\""
              echo 'if [ "${EUID:-$(id -u)}" -ne 0 ]; then'
              echo '  echo "run as root (kexec requires CAP_SYS_BOOT)" >&2'
              echo '  exit 1'
              echo 'fi'
              echo 'if ! command -v kexec >/dev/null 2>&1; then'
              echo '  echo "kexec not found; install kexec-tools" >&2'
              echo '  exit 1'
              echo 'fi'
              echo 'ONYX_KERNEL="$KERNEL" "$BIN"'
              echo 'kexec -e'
            } > "$WORKDIR/out/$WRAP_OUT"
            chmod +x "$WORKDIR/out/$WRAP_OUT"

            # keep per-target version marker
            echo "$LIBC" > "$WORKDIR/out/v_loader_lts${LTS}-arm64${LIBC_SUFFIX}.txt"

          else
            echo "Unknown matrix target: $MATRIX_TARGET_NAME"
            exit 1
          fi

      - name: List out/ for debug
        run: ls -la "$GITHUB_WORKSPACE/out" || true

      - name: Upload build outputs to GitHub release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ needs.prepare_release.outputs.snapshot_tag }}"
          shopt -s nullglob
          FILES=( "$GITHUB_WORKSPACE"/out/* )
          if [ "${#FILES[@]}" -eq 0 ]; then
            echo "No build outputs found in $GITHUB_WORKSPACE/out"
            exit 1
          fi
          gh release upload "$TAG" "${FILES[@]}" --clobber
